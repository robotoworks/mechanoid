grammar com.robotoworks.mechanoid.sqlite.SqliteModel with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate sqliteModel "http://www.robotoworks.com/mechanoid/sqlite/SqliteModel"

Model:
	'package' packageName=FQN
	database=DatabaseBlock;

DatabaseBlock:
	'database' name=ID '{' (actions=ActionBlock)? (migrations+=MigrationBlock)* '}';

ActionBlock:
	{ActionBlock}
	'actions' '{' (actions+=ActionStatement)* '}'
;

ActionStatement:
	name=ID path=STRING
;

MigrationBlock:
	{MigrationBlock}
	'migration' '{' (statements+=Statment ';' (statements+=Statment ';')*)? '}';
	
/*
 * Expressions
 */
 
Or returns Expression:
	And ({OrExpr.left=current} 'or' right=And)*
;

And returns Expression:
	PrimaryComparison ({AndExpr.left=current} 'and' right=PrimaryComparison)*
;

PrimaryComparison returns Expression:
	SecondaryComparison ({PrimaryComparisonExpr.left=current} op=SecondaryComparisonOp right=SecondaryComparison)*
;

SecondaryComparison returns Expression:
	Division ({SecondaryComparisonExpr.left=current} op=PrimaryComparisonOp right=Division)*
;

Division returns Expression:
	Multiplication ({DivisionExpr.left=current} '/' right=Multiplication)*
;

Multiplication returns Expression:
	Addition ({MultiplicationExpr.left=current} '*' right=Addition)*
;

Addition returns Expression:
	Subtraction ({AdditionExpr.left=current} '+' right=Subtraction)*
;

Subtraction returns Expression:
	PrimaryExpression ({SubtractionExpr.left=current} '-' right=PrimaryExpression)*
;

PrimaryExpression returns Expression:
	{ColumnLiteral} name=FQN |
	{Literal} literalValue=LiteralValue |
	'(' Or ')'
;

PrimaryComparisonOp:
	  '='
	| '=='
	| '!='
	| '<>'
	| 'is'
	| 'is not'
	| 'in'
	| 'like'
	| 'glob'
	| 'match'
	| 'regexp'
;

SecondaryComparisonOp:
	  '<'
	| '<='
	| '>'
	| '>='
;

/*
 * Statements
 */

Statment:
	{CreateTableStatement} 'create' 'table' name=ID '(' columnDefs+=ColumnDef (',' columnDefs+=ColumnDef)* (',' constraints+=TableConstraint)* ')' |
	{AlterTableStatement} 'alter' 'table' name=ID clause=AlterTableClause |
	{CreateViewStatement} 'create' 'view' name=ID 'as' selectStatement=SelectStatement;

TableDecl:
	name=ID
;

AlterTableClause:
	{AlterTableRenameClause} 'rename to' name=ID |
	{AlterTableAddColumnClause} 'add column' columnDef=ColumnDef;

ColumnDef:
	name=ID type=ColumnType constraints+=ColumnConstraint*;

ColumnConstraint:
	{PrimaryKeyColumnConstraint} 'primary' 'key' (asc?='asc'|desc?='desc')? autoincrement?='autoincrement'? |
	{NotNullConstraint} 'not' 'null' conflictClause=ConflictClause? |
	{DefaultConstraint} 'default' defaultValue=DefaultValue
;

DefaultValue:
	{LiteralDefaultValue} literal=LiteralValue |
	{ExpressionDefaultValue} '(' expression=Or ')'
;
TableConstraint:
	UniqueTableContraint /* | PrimaryKeyTableConstraint*/;

UniqueTableContraint:
	'unique' '(' columns+=IndexedColumn (',' columns+=IndexedColumn)* ')' conflictClause=ConflictClause;

	//	'primary key' '(' columns+=IndexedColumn (',' columns+=IndexedColumn)* ')' conflictClause=ConflictClause
//;
IndexedColumn:
	name=[ColumnDef] (asc?='asc'|desc?='desc')?;

enum ColumnType:
	text | integer | real | blob;

enum ConflictResolution:
	rollback | abort | fail | ignore | replace;

SelectStatement:
	core=SelectCore
;

SelectCore:
	'select' (distinct?='distinct'|all?='all')? resultColumns+=ResultColumn (',' resultColumns+=ResultColumn)*
	('from' source=JoinSource)?
;

JoinSource:
	source=SingleSource joinStatements+=JoinStatement*
;

SingleSource:
	{SingleSourceTable} tableName=ID ('as' name=ID)? |
	{SingleSourceSelectStatement} '(' selectStatement=SelectStatement ')' |
	{SingleSourceJoin} '(' joinSource=JoinSource ')'
;

JoinStatement:
	{JoinStatement}
	natural?='natural'? ((left?='left' outer?='outer'?) | inner?='inner' | cross?='cross')? 'join' singleSource=SingleSource 'on' expression=Or;
	
ResultColumn:
	{ResultColumnAll} '*' |
	{ResultColumnAllWithTableRef} tableRef=ID'.' '*' |
	{ResultColumnExpression} expression=Or ('as' name=ID)?
;

ConflictClause:
	'on' 'conflict' resolution=ConflictResolution;


LiteralValue:
	{NumericLiteral} number=SignedNumber |
	{StringLiteral} literal=STRING |
	{NullLiteral} literal='null' |
	{CurrentTimeLiteral} literal='current_time' |
	{CurrentDateLiteral} literal='current_date' |
	{CurrentTimeStampLiteral} literal='current_time_stamp'
;

SignedNumber returns ecore::EBigDecimal:
	'-'?NUMBER
;	

terminal NUMBER returns ecore::EBigDecimal:
	('0'..'9')* ('.' ('0'..'9')+)?;
	
terminal INT returns ecore::EInt: 
	"$$$don't use this anymore$$$";
	
terminal STRING	: 
		"'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|"'") )* "'"
;

FQN:
	ID ("." ID)*;