grammar com.robotoworks.mechanoid.sqlite.SqliteModel with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate sqliteModel "http://www.robotoworks.com/mechanoid/sqlite/SqliteModel"

Model:
	'package' packageName=FQN
	database=DatabaseBlock;

DatabaseBlock:
	'database' name=ID '{' (config=ConfigBlock)? (migrations+=MigrationBlock)* '}';

ConfigBlock:
	{ConfigBlock}
	'config' '{' statements+=ConfigurationStatement* '}'
;

ConfigurationStatement:
	{ActionStatement} 'action' name=ID path=STRING |
	{ActiveRecordRegistrationStatement} 'active' name=ID
;

MigrationBlock:
	{MigrationBlock}
	'migration' '{' (statements+=Statement ';' (statements+=Statement ';')*)? '}';
	
/*
 * Expressions
 */

SqlExpression:
	root=ExprConcat
;

ExprConcat returns Expression:
	ExprMult ({ExprConcat.left=current} op='||' right=ExprMult)*
;

ExprMult returns Expression:
	ExprAdd ({ExprMult.left=current} op=('*'|'/'|'%') right=ExprAdd)*
;

ExprAdd returns Expression:
	ExprBit ({ExprAdd.left=current} op=('+'|'-') right=ExprBit)*
;

ExprBit returns Expression:
	ExprRelate ({ExprBit.left=current} op=('<<'|'>>'|'&'|'|') right=ExprRelate)*
;

ExprRelate returns Expression:
	ExprEqual ({ExprRelate.left=current} op=('<'|'<='|'>'|'>=') right=ExprEqual)*
;

ExprEqual returns Expression:
	ExprAnd ({ExprEqual.left=current} 
		op=('='|'=='|'!='|'<>'|'is'|'is not'|'in'|'like'|'glob'|'match'|'regexp') 
		right=ExprAnd
	)*
;

ExprAnd returns Expression:
	ExprOr ({ExprAnd.left=current} op='and' right=ExprOr)*
;

ExprOr returns Expression:
	PrimaryExpression ({ExprOr.left=current} op='or' right=PrimaryExpression)*
;

PrimaryExpression returns Expression:
	(
		{ColumnLiteral} name=FQN |
		{Literal} literalValue=LiteralValue |
		'(' SqlExpression ')' |
		{SelectStatementExpression} not?='not'? exists?='exists'? '(' select=SelectStatement ')'|
		{CaseExpression} 'case' caseExpression=SqlExpression? 
				cases+=Case cases+=Case*
				('else' elseExpression=SqlExpression)? 'end' |
		{Function} name=ID '(' (all?='*'|arguments+=SqlExpression (',' arugments+=SqlExpression)*) ')'
	) isnull?=('is null'|'not null' | 'notnull')?
;

Case:
'when' whenExpression=SqlExpression 'then' thenExpression=SqlExpression
;

/*
 * Statements
 */

Statement:
	{CreateTableStatement} 'create' 'table' name=ID '(' columnDefs+=ColumnDef (',' columnDefs+=ColumnDef)* (',' constraints+=TableConstraint)* ')' |
	{AlterTableStatement} 'alter' 'table' name=ID clause=AlterTableClause |
	{CreateViewStatement} 'create' 'view' name=ID 'as' selectStatement=SelectStatement |
	{DropTableStatement} 'drop' 'table' ('if' 'exists')? name=ID |
	{DropViewStatement} 'drop' 'view' ('if' 'exists')? name=ID;

AlterTableClause:
	{AlterTableRenameClause} 'rename to' name=ID |
	{AlterTableAddColumnClause} 'add column' columnDef=ColumnDef;

ColumnDef:
	name=ID type=ColumnType constraints+=ColumnConstraint*;

ColumnConstraint:
	{PrimaryKeyColumnConstraint} 'primary' 'key' (asc?='asc'|desc?='desc')? autoincrement?='autoincrement'? |
	{NotNullConstraint} 'not' 'null' conflictClause=ConflictClause? |
	{DefaultConstraint} 'default' defaultValue=DefaultValue
;

DefaultValue:
	{LiteralDefaultValue} literal=LiteralValue |
	{ExpressionDefaultValue} '(' expression=SqlExpression ')'
;
TableConstraint:
	{UniqueTableContraint} ('constraint' name=ID)? 'unique' '(' columns+=IndexedColumn (',' columns+=IndexedColumn)* ')' conflictClause=ConflictClause |
	{PrimaryContraint} ('constraint' name=ID)? 'primary' 'key' '(' columns+=IndexedColumn (',' columns+=IndexedColumn)* ')' conflictClause=ConflictClause |
	{CheckTableConstraint} ('constraint' name=ID)? 'check' '(' expression=SqlExpression ')'
;
IndexedColumn:
	name=[ColumnDef] (asc?='asc'|desc?='desc')?;

enum ColumnType:
	text | integer | real | blob;

enum ConflictResolution:
	rollback | abort | fail | ignore | replace;

SelectStatement:
	coreStatements+=SelectCore (CompoundOperator coreStatements+=SelectCore)*
	('order' 'by'  orderingTerms+=OrderingTerm (',' orderingTerms+=OrderingTerm)*)?
;

CompoundOperator:
	'union all' | 'union' | 'intersect' | 'except'
;

OrderingTerm:
	expression=SqlExpression (asc?='asc'|desc?='desc')?
;

SelectCore:
	'select' (distinct?='distinct'|all?='all')? resultColumns+=ResultColumn (',' resultColumns+=ResultColumn)*
	('from' source=JoinSource)?
	('where' whereExpression=SqlExpression)?
	('group' 'by'  groupByExpressions+=SqlExpression (',' groupByExpressions+=SqlExpression)*)?
;

JoinSource:
	source=SingleSource joinStatements+=JoinStatement*
;

SingleSource:
	{SingleSourceTable} tableName=ID ('as' name=ID)? |
	{SingleSourceSelectStatement} '(' selectStatement=SelectStatement ')' |
	{SingleSourceJoin} '(' joinSource=JoinSource ')'
;

JoinStatement:
	{JoinStatement}
	natural?='natural'? ((left?='left' outer?='outer'?) | inner?='inner' | cross?='cross')? 'join' singleSource=SingleSource 'on' expression=SqlExpression;
	
ResultColumn:
	{ResultColumnAll} '*' |
	{ResultColumnAllWithTableRef} tableRef=ID'.' '*' |
	{ResultColumnExpression} expression=SqlExpression ('as' name=ID)?
;

ConflictClause:
	'on' 'conflict' resolution=ConflictResolution;


LiteralValue:
	{NumericLiteral} number=SignedNumber |
	{StringLiteral} literal=STRING |
	{NullLiteral} literal='null' |
	{CurrentTimeLiteral} literal='current_time' |
	{CurrentDateLiteral} literal='current_date' |
	{CurrentTimeStampLiteral} literal='current_time_stamp'
;

SignedNumber returns ecore::EBigDecimal:
	'-'?NUMBER
;	

terminal NUMBER returns ecore::EBigDecimal:
	('0'..'9')* ('.' ('0'..'9')+)?;
	
terminal INT returns ecore::EInt: 
	"$$$don't use this anymore$$$";
	
terminal STRING	: 
			'"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|'"') )* '"' |
			"'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|"'") )* "'"
		; 

FQN:
	ID ("." ID)*;