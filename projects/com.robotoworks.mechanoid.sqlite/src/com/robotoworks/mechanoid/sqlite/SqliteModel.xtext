grammar com.robotoworks.mechanoid.sqlite.SqliteModel with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate sqliteModel "http://www.robotoworks.com/mechanoid/sqlite/SqliteModel"

Model:
	'package' packageName=FQN
	database=DatabaseBlock;

DatabaseBlock:
	'database' name=ID '{' (actions=ActionBlock)? (migrations+=MigrationBlock)* '}';

ActionBlock:
	{ActionBlock}
	'actions' '{' (actions+=ActionStatement)* '}'
;

ActionStatement:
	name=ID path=STRING
;

MigrationBlock:
	{MigrationBlock}
	'migration' '{' (statements+=Statment ';' (statements+=Statment ';')*)? '}';
	
/*
 * Expressions
 */

SqlExpression:
	root=Or
;
Or returns Expression:
	And ({Or.left=current} 'or' right=And)*
;

And returns Expression:
	PrimaryComparison ({And.left=current} 'and' right=PrimaryComparison)*
;

PrimaryComparison returns Expression:
	SecondaryComparison ({PrimaryComparison.left=current} op=SecondaryComparisonOp right=SecondaryComparison)*
;

SecondaryComparison returns Expression:
	Division ({SecondaryComparison.left=current} op=PrimaryComparisonOp right=Division)*
;

Division returns Expression:
	Multiplication ({Division.left=current} '/' right=Multiplication)*
;

Multiplication returns Expression:
	Addition ({Multiplication.left=current} '*' right=Addition)*
;

Addition returns Expression:
	Subtraction ({Addition.left=current} '+' right=Subtraction)*
;

Subtraction returns Expression:
	PrimaryExpression ({Subtraction.left=current} '-' right=PrimaryExpression)*
;

PrimaryExpression returns Expression:
	(
		{ColumnLiteral} name=FQN |
		{Literal} literalValue=LiteralValue |
		'(' SqlExpression ')' |
		{SelectStatementExpression} not?='not'? exists?='exists'? '(' select=SelectStatement ')'|
		{CaseExpression} 'case' caseExpression=SqlExpression? 
				cases+=Case cases+=Case*
				('else' elseExpression=SqlExpression)? 'end' |
		{Function} name=ID '(' (all?='*'|arguments+=SqlExpression (',' arugments+=SqlExpression)*) ')'
	) isnull?=('is null'|'not null' | 'notnull')?
;

Case:
'when' whenExpression=SqlExpression 'then' thenExpression=SqlExpression
;

PrimaryComparisonOp:
	  '='
	| '=='
	| '!='
	| '<>'
	| 'is'
	| 'is not'
	| 'in'
	| 'like'
	| 'glob'
	| 'match'
	| 'regexp'
;

SecondaryComparisonOp:
	  '<'
	| '<='
	| '>'
	| '>='
;

/*
 * Statements
 */

Statment:
	{CreateTableStatement} 'create' 'table' name=ID '(' columnDefs+=ColumnDef (',' columnDefs+=ColumnDef)* (',' constraints+=TableConstraint)* ')' |
	{AlterTableStatement} 'alter' 'table' name=ID clause=AlterTableClause |
	{CreateViewStatement} 'create' 'view' name=ID 'as' selectStatement=SelectStatement;

TableDecl:
	name=ID
;

AlterTableClause:
	{AlterTableRenameClause} 'rename to' name=ID |
	{AlterTableAddColumnClause} 'add column' columnDef=ColumnDef;

ColumnDef:
	name=ID type=ColumnType constraints+=ColumnConstraint*;

ColumnConstraint:
	{PrimaryKeyColumnConstraint} 'primary' 'key' (asc?='asc'|desc?='desc')? autoincrement?='autoincrement'? |
	{NotNullConstraint} 'not' 'null' conflictClause=ConflictClause? |
	{DefaultConstraint} 'default' defaultValue=DefaultValue
;

DefaultValue:
	{LiteralDefaultValue} literal=LiteralValue |
	{ExpressionDefaultValue} '(' expression=SqlExpression ')'
;
TableConstraint:
	UniqueTableContraint /* | PrimaryKeyTableConstraint*/;

UniqueTableContraint:
	'unique' '(' columns+=IndexedColumn (',' columns+=IndexedColumn)* ')' conflictClause=ConflictClause;

	//	'primary key' '(' columns+=IndexedColumn (',' columns+=IndexedColumn)* ')' conflictClause=ConflictClause
//;
IndexedColumn:
	name=[ColumnDef] (asc?='asc'|desc?='desc')?;

enum ColumnType:
	text | integer | real | blob;

enum ConflictResolution:
	rollback | abort | fail | ignore | replace;

SelectStatement:
	core=SelectCore
	('order' 'by'  orderingTerms+=OrderingTerm (',' orderingTerms+=OrderingTerm)*)?
;

OrderingTerm:
	expression=SqlExpression (asc?='asc'|desc?='desc')?
;

SelectCore:
	'select' (distinct?='distinct'|all?='all')? resultColumns+=ResultColumn (',' resultColumns+=ResultColumn)*
	('from' source=JoinSource)?
	('group' 'by'  groupByExpressions+=SqlExpression (',' groupByExpressions+=SqlExpression)*)?
;

JoinSource:
	source=SingleSource joinStatements+=JoinStatement*
;

SingleSource:
	{SingleSourceTable} tableName=ID ('as' name=ID)? |
	{SingleSourceSelectStatement} '(' selectStatement=SelectStatement ')' |
	{SingleSourceJoin} '(' joinSource=JoinSource ')'
;

JoinStatement:
	{JoinStatement}
	natural?='natural'? ((left?='left' outer?='outer'?) | inner?='inner' | cross?='cross')? 'join' singleSource=SingleSource 'on' expression=SqlExpression;
	
ResultColumn:
	{ResultColumnAll} '*' |
	{ResultColumnAllWithTableRef} tableRef=ID'.' '*' |
	{ResultColumnExpression} expression=SqlExpression ('as' name=ID)?
;

ConflictClause:
	'on' 'conflict' resolution=ConflictResolution;


LiteralValue:
	{NumericLiteral} number=SignedNumber |
	{StringLiteral} literal=STRING |
	{NullLiteral} literal='null' |
	{CurrentTimeLiteral} literal='current_time' |
	{CurrentDateLiteral} literal='current_date' |
	{CurrentTimeStampLiteral} literal='current_time_stamp'
;

SignedNumber returns ecore::EBigDecimal:
	'-'?NUMBER
;	

terminal NUMBER returns ecore::EBigDecimal:
	('0'..'9')* ('.' ('0'..'9')+)?;
	
terminal INT returns ecore::EInt: 
	"$$$don't use this anymore$$$";
	
terminal STRING	: 
		"'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|"'") )* "'"
;

FQN:
	ID ("." ID)*;