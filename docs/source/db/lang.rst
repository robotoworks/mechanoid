Defining Databases
==================
The |mechdb| language supports most of the SQL grammar for Sqlite, if you 
know SQL then you know most of the |mechdb| grammar.

Additionally, |mechdb| has its own grammar constructs mainly for defining
structure, such as schema migrations using the **migration** keyword.

Each time you modify a |mechdb| File, such as adding new migrations and
statements, corresponding code is generated that makes up the generated
Content Provider API for your database.

This topic will focus on the |mechdb| grammar, and refer 
to examples of generated code where it seems appropriate.

See |ref| :doc:`api` for detailed usage of the generated API.

.. note:: 
   Although |mechdb| uses the Sqlite syntax, all keywords in 
   |mechdb| are lower cased, for instance use the keyword **select** instead
   of **SELECT**

The Mechanoid DB File
---------------------
To define a database, we need to create a |mechdb| File.

A |mechdb| File has the ``mechdb`` extension, for instance 
``recipes.mechdb``, the file can be created in Eclipse using the |mechdb| Wizard.

In Eclipse, there are several ways to start a wizard, one way is to right click
(or CTRL + Click on Mac) on an item in Package Explorer, then choose 
``New > Other > Mechanoid > Mechanoid DB File``, the |mechdb| File Wizard
will launch.

.. figure:: /images/screens/wizard-mechdb.png

The following should be considered when providing values for the wizard.

* **Folder** is where you want to create the file typically ``/project/models`` 
  is a good place to keep your Mechanoid Files.
* **Package** is where you want to generate the code, all code will be generated 
  to the given java package.
* **Name** is the name of your sqlite database, this name will be used for 
  your generated SqliteOpenHelper.

On completing the wizard, a new file is created, the contents will contain an 
empty definition of a database with a single migration.

.. code-block:: mechdb
   
   package com.example.recipes.content
   
   database RecipesDB {
      migration {
         
      }
   }

.. note::

   To learn more about how |mechdb| supports schema migrations, 
   see |ref| :ref:`schema-migrations`

The Database Definition
-----------------------
In mechdb file, we define a single database block as follows.

.. code-block:: mechdb

   database RecipesDB {
      migration {
         
      }
   }
   
A database block can contain many migrations, a migration represents a schema
change from one migration to another, a migration can contain many statements,
such as create table statements, views and triggers.

.. topic:: The generated code

   When editing and saving mechdb files, code is generated, given a database
   with the name of RecipesDB, as in the above example, the following code is
   generated.
   
   * ``RecipesDBContract`` which contains constants for table and view columns, 
     Content URI constants for use with the generated content provider, and 
     convenience methods and builders.
   * A user editable ``RecipesDBContentProvider``, and a base 
     ``AbstractRecipesDBContentProvider`` that contains the generated logic
     to access your database
   * A user editable ``RecipesDBOpenHelper``, and a base ``AbstractRecipesDBOpenHelper``
     that contains all the generated code that creates your database from one
     version to the next
   
   .. note:: 
   
      Code that should not be edited is generated by default to the **src-gen** folder.
      Code that can be edited with by generated by default to the **src** folder.

Defining Tables
---------------
In |mechdb|, we define our data model using tables, in the same way we
do with Sqlite, the following example shows how to define a table.

.. code-block:: mechdb
   
   package com.example.recipes.content
   
   database RecipesDB {
      migration {
         create table recipes (
            _id integer primary key autoincrement,
            title text,
            description text
         );
      }
   }
   
.. warning::
   You should always define an **_id** column, if you plan to use the Android
   Cursor Adapter API then an _id column is required.

.. topic:: The generated code

   For each table, a corresponding class of the same name is generated into a 
   contract class, for instance given the ``RecipesDBContract`` contract, for
   a ``recipes`` table a corresponding ``RecipesDBContract.Recipes`` class will
   be generated.
   
   Columns can then be access, such as ``Recipes.TITLE``, or ``Recipes._ID``.
   
   Additionally, other helpful code such as record builders are generated:-
   
   .. code-block:: java
   
      //
      // We can create new recipes with the generated recipes builder
      //
      Uri omletteUri = Recipes.newBuilder()
           .setTitle("Omelette")
           .setDescription("Wonderful omelette with cheese")
           .insert();
      
   .. todo:: Link to topic describing usage of generated code
   
   
|link| Learn more: http://www.sqlite.org/lang_createtable.html

Altering Tables
---------------
Sqlite allows us to change the name of tables, or add new columns. The following
example shows how we can do this.

.. code-block:: mechdb
   
   migration {
   
      alter table recipes rename to formulas;
      
      alter table formulas add column magic_words text;
      
   }
   
After renaming a table, you will no longer be able to reference its old name
in subsequent statements.
   
.. note:: 

   Changing the names of tables will also change the name in the generate code.
   
   For instance if you referenced the generated ``Recipes`` class anywhere in your 
   code, the code will fail to compile if you renamed it to ``Formulas``.

Currently it is not possible to alter the name of a column, or drop a column
with Sqlite, and Mechanoid provides no workaround for this.
   
|link| Learn more: http://www.sqlite.org/lang_altertable.html

Dropping Tables
---------------
The following example shows how to drop a table.

.. code-block:: mechdb
   
   migration {
      drop table formulas;
   }
   
After dropping a table, you will no longer be able to reference it in
subsequent statements.
   
.. note:: 

   Dropping tables will also remove the generated code for that table, if you
   have any references to the ``Formulas`` table, then compile time errors will
   occur.
   
|link| Learn more: http://www.sqlite.org/lang_droptable.html

Creating Views
--------------
Views in Sqlite allow us to combine results from one or many sources, 
|mechdb| supports views as in Sqlite. The follwing example shows how to do 
this.

.. code-block:: mechdb

   create view recipes_with_authors as
      select
         r._id as _id,
         r.title as recipe_title,
         r.description as recipe_description,
         r.author_id as author_id,
         a.name as author_name
      from recipes as r
      left join authors as a
      on r.author_id = a._id;
      
.. topic:: The generated code

   Much like tables, for each view defined in your mechdb file, a corresponding 
   class is generated, for instance ``RecipesDBContract.RecipesWithAuthors``.
   
   In order for columns to be available in your contract, such as
   ``RecipesWithAuthors.RECIPE_TITLE`` you must alias them
   with the **as** keyword, for instance ``r.title as recipe_title``, if
   you do not do this then the generator will just ignore them.
   
|link| Learn more: http://www.sqlite.org/lang_createview.html

Dropping Views
--------------
Dropping views is similar to dropping tables.

.. code-block:: mechdb
   
   migration {
      drop view recipes_with_authors;
   }
   
.. note:: 

   Like dropping tables, dropping a view will also remove any generated code for 
   instance the ``RecipesWithAuthors`` contract class.
   
|link| Learn more: http://www.sqlite.org/lang_dropview.html

Creating Triggers
-----------------
Triggers are useful when you want to update related data based on changes in
other tables, the following example shows how to define a trigger in |mechdb|,
The syntax is exactly the same as in Sqlite.

.. code-block:: mechdb

   migration {
      create trigger update_number_of_ingredients after
         insert on ingredients
         begin
            update recipes set num_ingredients = (
               select count(*) from ingredients
               where ingredients.recipe_id = new.recipe_id
            );
         end;
   }
   
In the example, the trigger defines that after we insert into 
the ``ingredients`` table, we should update the ``recipes`` table by setting
the column ``num_ingredients`` to the total number of recipes.

|link| Learn more: http://www.sqlite.org/lang_createtrigger.html

Dropping Triggers
-----------------
The following example shows how to drop a trigger.

.. code-block:: mechdb
   
   migration {
      drop trigger update_number_of_ingredients;
   }
   
|link| Learn more: http://sqlite.org/lang_droptrigger.html

.. _schema-migrations:

Schema Migrations
-----------------
|mechdb| was created with schema migrations as a first class requirement, all
creational statements such as create table, create view, drop table, etc are
defined in migration blocks, for example:-

.. code-block:: mechdb
   
   migration {
      create table table_one (
         _id integer primary key autoincrement
      );
   }

Migrations blocks represent versions of the database, implicitly by order of
appearance, for instance:-

.. code-block:: mechdb
   
   // Database Version 1
   migration {
      create table table_one (
         _id integer primary key autoincrement
      );
   }
   
   // Database Version 2
   migration {
      create table table_two (
         _id integer primary key autoincrement
      );
   }
   
   // Database Version 2
   migration {
      drop table_one;
   }
   
   // etc ...
   
|mechdb| tries to do its best to make sure that everything is valid, for instance
it is an error to drop a table then reference it:

.. code-block:: mechdb
   :emphasize-lines: 9, 11
   
   migration {
      create table table_one (
         _id integer primary key autoincrement
      );
   }
   
   migration {
      drop table table_one;
      
      create view view_one on
         select _id as id from table_one;
   }
   
The create view statement above would fail since ``table_one`` was dropped in
the previous statement.

.. topic:: The generated code
   
   For each migration, code is generated that represents one change from
   the other.
   
   Most of the time making changes to the database schema is enough and nothing 
   more needs to be done, however in some circumstances, data also needs 
   to be migrated.

   In order to migrate data in |mechdb| we can add code before and after a 
   migration by overriding methods in the generated ``SqliteOpenHelper`` as 
   follows:
   
   .. code-block:: java
      
      public class RecipesDBOpenHelper extends AbstractRecipesDBOpenHelper {
          public RecipesDBOpenHelper(Context context) {
              super(context);
          }
           
          @Override
          protected SQLiteMigration createRecipesDBMigrationV2() {
              return new DefaultRecipesDBMigrationV2(){
                  @Override
                  public void onBeforeUp(SQLiteDatabase db) {
                      // TODO Do something before the migration
                  }
                  
                  @Override
                  public void onAfterUp(SQLiteDatabase db) {
                      // TODO Do something before the migration
                  }
              };
          }
      }
      
   Above we can return our own implementation a specific migration and add code 
   before and after the by overriding the ``onBeforeUp(SQLiteDatabase)`` and
   ``onAfterUp(SQLiteDatabase) methods respectively, its important that we subclass 
   the right migration, in this case its ``DefaultRecipesDBMigrationV2``, where 
   the format for migration classes is ``Default{database_name}MigrationV{version_number}``.
   
   .. warning::
      By overriding migrations in this way it is entirely possible to also
      make schema changes, but this could cause your |mechdb| File to be
      out of sync with what is actually the schema of the database, if you really 
      need to make scheme changes in this way, make sure you know what your doing.

Initialization Block
--------------------
Sometimes it makes more sense to create temporary views or tables, especially in the case
of views that may change from migration to migration, which can introduce a maintenance
overhead if your views are quite large in definition.

The initialization block can include create temp view and table statements that are executed
once when the database is first opened.

The following example shows how to define a temporary view in the initialization block.

.. code-block:: mechdb

    database RecipesDB {
        init {
            create temp view recipes_with_authors as
                select
                    r._id as _id,
                    r.title as recipe_title,
                    r.description as recipe_description,
                    r.author_id as author_id,
                    a.name as author_name
                from recipes as r
                left join authors as a
                on r.author_id = a._id;
        }
    }

The code generated for a temp view or table in the init block is exactly the same as
it would be if they were defined in a migration.

By defining views like this means you do not need to manage them when they change over
migrations and can be edited in place with no concern to Android database upgradability.