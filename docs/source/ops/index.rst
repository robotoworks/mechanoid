.. |opsvc| replace:: Operation Service
.. |opsvcdef| replace:: Operation Service Definition

|mechops|
=========
.. note:: 
   You must install the Mechanoid Plugin before you can use |mechops|.
   |ref| See :doc:`/start`
   
|mechops| is a framework for defining and performing potentially long-running 
asynchronous operations, decoupled from your UI.

You define your operations using a simple language (DSL), implement some 
generated operation stubs and then use a generated API to execute them.

The approach makes use of the Android ``Service`` Component, along with support 
classes to queue operations, execute operations and handle operation life-cycle 
callbacks.

The design pattern was first seen in 
|link| `Virgil Dobjanschi's Google IO 2010 REST Presentation <http://www.youtube.com/watch?v=xHXn3Kg2IQE>`_

In |mechops| we call this design the **Operation Service Pattern**.

In |mechops| we define an |opsvc| using a simple language (DSL), for example:-

.. code-block:: mechops

   package com.robotoworks.example.movies.ops
   
   service Movies {
      operation getMovies()
      operation addMovie(String title, String description, int year)
   }
   
In this example we define two operations, ``getMovies()`` and ``addMovie(...)``.

We can then use the generated code to execute them:

.. code-block:: java

   MoviesServiceBridge service = MoviesServiceBridge.getInstance();
   
   int id = service.executeAddMovieOperation("The Godfather", "Movie about gangstas.", 1972);
   
The following sections describe the syntax of the DSL, and how we can use the
generated |opsvc| API.

.. topic:: Example Project

   The examples used in this documentation are based on an example project available
   on github:
   
   |link| https://github.com/robotoworks/mechanoid/tree/master/examples/movies

The |mechops| File
------------------
We define our |opsvc| in a file with the extension ``mechops``,
for instance ``movies.mechops``.

We can create a mechops file using the |mechops| File Wizard. In eclipse go to
``New > Other > Mechanoid > Mechanoid Ops File``, the |mechops| wizard will
launch:

.. figure:: /images/screens/wizard-mechops.png


The following should be considered when providing values for the wizard.

* **Folder** is where you want to create the file typically ``/project/models`` 
  is a good place to keep your Mechanoid Files.
* **Package** is where you want to generate the code, all code will be generated 
  to the given java package.
* **Name** is the name of your operation service, this name will be used as a 
  prefix for all the classes that make up your Operation Service API
  
On completing the wizard, a new file will be created, the contents will
contain an empty service definition:

.. code-block:: mechops

   package com.robotoworks.example.movies.ops
   
   service Movies {
      
   }
   
The Service Definition
----------------------
In |mechops| we use the ``service`` keyword followed by a unique name to define
a single Operation Service.

The following example shows how we define a service.

.. code-block:: mechops

   service Movies {
      
   }
   
In a service definition we can define many operations discussed in the following
sections.

.. topic:: The generated code

   When editing and saving mechnet files, code is generated, given a service
   with the name of ``Movies``, as in the above example, the following code is
   generated.
   
   * A user editable ``MoviesServiceBridge``, and a base ``AbstractMoviesServiceBridge``,
     that handles Service Intent construction and callback management, this is the
     class you use to execute operations.
   * A user editable ``MoviesService``, and a base ``AbstractMoviesService``, the
     service mainly delegates incoming intent to an ``OperationProcessor``, you
     do not normally need to touch this but you may want to change the services
     behavior slightly such as making it a foreground service.
   * A user editable ``MoviesProcessor``, and a base ``AbstractMoviesProcessor``, 
     this is where operations are queued and executed using a ``HandlerThread``.
   * A user editable ``MoviesOperationRegistry`` and a base 
     ``AbstractMoviesOperationRegistry``, this is where intent actions and operation
     implementations are associated.
     
   In most circumstances you should not need to edit any of the generated files,
   if you do need to edit them, then you should only edit the user editable files.
   
   .. note:: 

      Code that should not be edited is generated by default to the **src-gen** folder.
      Code that can be edited with by generated by default to the **src** folder.

Registering the Service
-----------------------
|mechops| uses an Android ``Service`` component implementation for every 
|opsvcdef|, this service must be registered in the ``AndroidManifest.xml``
like any other service.

Taking the ``Movies`` service example defined in the previous section, a 
``MoviesService`` class will be generated which should be registered as follows:

.. code-block:: xml

   <service
      android:name="com.robotoworks.example.movies.ops.MoviesService"
      android:exported="false" >
   </service>

The format of the generated Android ``Service`` would be 
``{package_name}{service_name}Service``, where ``{package_name}`` is the name 
of the package element in your service definition, and likewise, 
``{service_name}`` is the name of your service, in our case, ``Movies``, which
makes the complete name ``com.robotoworks.example.movies.ops.MoviesService``.
   
Defining Operations
-------------------
Defining Operations with |mechops| is similar to defining methods in java, with
the exception that |mechops| only supports primitives and ``Parcelable`` for
operation arguments, for example:

.. code-block:: mechops

   package com.robotoworks.example.movies.ops
   
   service Movies {
      operation getMovies()
      operation addMovie(String title, String description, int year)
   }
   
The example defines two operations, an argumentless ``getMovies()`` operation, 
and a ``addMovie(...)`` operation with arguments.

.. _operation-uniqueness:

Operation Uniqueness
--------------------
By default, when using the generated Operation Service API, when executing 
operations, all operations are considered unique.

An operation that is unique is an operation where only one of its kind can
exist in the background queue, or one that is currently executing.

An operation is considered unique if it is of the same signature and has the same 
argument values, for instance ``addMovie(String, String, int)``.

We can use the generated API to execute operations:

.. code-block:: java

   MoviesServiceBridge service = MoviesServiceBridge.getInstance();
   
   int op1 = service.executeAddMovieOperation("The Godfather", "Movie about gangstas.", 1972);
   int op2 = service.executeAddMovieOperation("The Godfather", "Movie about gangstas.", 1972);

If an operation is unique, in the example above, executing the second operation
would return the same result (Operation Request ID), if the first operation is 
in the queue or currently executing, such that ``op1 == op2``.

.. topic:: Why Make Operations Unique?

   Making operations unique reduces power consumption and in some cases network 
   bandwidth by executing the same operation as little times as possible, if
   two callers need to execute the same operation with the same arguments it
   stands to reason that they are interested in the same result, |mechops| deals
   with this in a smart way by intercepting this and returning the same 
   Operation Request ID, when the operation completes they both receive the a 
   callback from the same completing operation.

We can specify that an operation should not be unique, with the ``not unique``
keyword, for instance:

.. code-block:: mechops

   package com.robotoworks.example.movies.ops
   
   service Movies {
      operation getMovies()
      operation addMovie(String title, String description, int year) not unique
   }
   
Executing the same operation in succession that is ``not unique`` will always
be added to the operation queue.

Sometimes we just want an operation to be partially unique, we can do this
by specifying a unique clause and a list of arguments that make it unique,
for instance, we can make the ``addMovie(...)`` operation unique by its title.

.. code-block:: mechops

   package com.robotoworks.example.movies.ops
   
   service Movies {
      operation getMovies()
      operation addMovie(String title, String description, int year) unique(title)
   }

Executing this operation, will only be added to the queue if an operation is
not currently in the queue with the same title, or currently executing with
the same title.

We can specify many arguments that make an operation unique in a comma separated 
list, for instance:

.. code-block:: mechops

   operation addMovie(String title, String description, int year) unique(title, year)

Implementing Operations
-----------------------
For each operation defined in the |opsvcdef|, a class stub is generated, with
the format of the class name as ``{operation_id}Operation`` where ``operation_id``
is the identifier given to the operation, ie:- ``getMovies()`` becomes ``GetMoviesOperation``.

.. warning:: 
   Currently, when renaming operations, a new stub is generated which would make 
   the old stub cause a compile error, if you have implemented a stub, and want to
   keep the code then you should copy it into the new stub
   
The following example shows the generated stub for ``GetMoviesOperation``:

.. code-block:: java

   public class GetMoviesOperation extends AbstractGetMoviesOperation {
      @Override
      protected Bundle onExecute() {
         // TODO Auto-generated method stub
         return null;
      }
   }
   
When we implement operations, we add code to the ``onExecute()`` method, and
return a ``Bundle`` that represents a result.

The ``Bundle`` we return should be constructed with the Mechanoid API method, 
:java:extdoc:`Operation.createOkResult() <com.robotoworks.mechanoid.ops.Operation.createOkResult()>` to
indicate that the operation was successful, or 
:java:extdoc:`Operation.createErrorResult(Throwable) <com.robotoworks.mechanoid.ops.Operation.createErrorResult(java.lang.Throwable)>` 
to indicate that an error occurred.

The following example shows how we could implement the ``onExecute()`` of
the ``GetMoviesOperation`` stub.

.. code-block:: java

   @Override
   protected Bundle onExecute() {
      
      MoviesApiClient client = MoviesApplication.getMoviesApiClient();
      
      try {
         Response<GetMoviesResult> response = client.getMovies();
         
         // Throws UnexpectedHttpStatusException if not 200 OK 
         response.checkResponseCodeOk();
         
         GetMoviesResult result = response.parse();
         
         saveMovies(result.getMovies());
         
         return Operation.createOkResult();
         
      } catch (Exception e) {
         Log.e(TAG, Log.getStackTraceString(e));
         
         return Operation.createErrorResult(e);
      }
   }

For the purposes of the example, we retrieve data using a REST client, the 
example demonstrates how we should construct the result. As previously outlined, 
if everything is ok, we return ``Operation.createOkResult()``, in the event of 
an error we return ``Operation.createErrorResult(Throwable)``.

Operations with arguments, such as the ``addMovie(...)`` operation we saw earlier,
make their arguments available to the operation stub through properties, for instance
given the operation:

.. code-block:: mechops

   operation addMovie(String title, String description, int year) 

We can access the arguments in ``onExecute()`` as follows:

.. code-block:: java

   @Override
   protected Bundle onExecute() {
      
      // We can get arguments like this:
      String title = getTitle();
      String description = getDescription();
      int year = getYear();
      
      ...
   }
   
.. _executing-operations:

Executing Operations
--------------------
Every |opsvcdef| results in a generated implementation of 
:java:extdoc:`OperationServiceBridge <com.robotoworks.mechanoid.ops.OperationServiceBridge>`  
for instance ``MoviesServiceBridge``.

The bridge acts as a proxy to the service (eg:- ``MoviesService``). It is responsible
for constructing service intents, handling operation uniqueness, and also dispatching
callbacks to registered instances of ``OperationServiceListener``.

By default bridges are generated as singletons, in order for a bridge to work
correctly it must either be a singleton or created in a way that makes a single
instance accessible (ie:- managed by a dependency container), for example, we 
can get an instance of the ``MoviesServiceBridge`` like this:

.. code-block:: java

   MoviesServiceBridge bridge = MoviesServiceBridge.getInstance();

Once we have an instance of a bridge, we gain access to the methods we defined
in our |opsvcdef|, the following example shows how we can use the bridge to
execute these operations:

.. code-block:: java

   MoviesServiceBridge bridge = MoviesServiceBridge.getInstance();
   
   int id = bridge.executeAddMovieOperation("The Godfather", "Movie about gangstas.", 1972);
   
The method ``executeAddMovieOperation(...)`` is the generated version of
the method we defined in our |opsvcdef| earlier ``addMovie(...)``.

Every operation always returns an Operation Request ID, for each new operation an 
incrementing ID is assigned that uniquely identifies an operation request, 
with the exception of operation uniqueness (see |ref| :ref:`operation-uniqueness`) 
where the same ID could be returned for a pending or currently executing operation.

.. topic:: The Request ID
   
   Executing operations with the bridge happens asynchronously, behind the scenes
   a request to execute the operation is put into a queue managed by an ``OperationProcessor``.
   The operation processor is responsible for taking the next operation from the
   queue and executing it until no operations are left to process.
   
   With this in mind, when we invoke an ``execute`` method on a bridge, we
   get a **Request ID** back, which we can use to uniquely identify an operation.
   
   In order to know what is happening with an operation, we rely on callbacks 
   discussed later.
 
As well as executing operations we can also use the bridge to check if an 
operation is pending completion (either in the queue or executing), for this
we need the Operation Request ID that was returned to us when we executed
the operation:

.. code-block:: java

   boolean pending = bridge.isRequestPending(id);
   
  
The Operation Manager
---------------------
As previously mentioned when executing operations from a UI class such as 
an ``Activity`` or a ``Fragment`` we can use the ``OperationManager``, or, 
the ``SupportOperationManager`` if we want backward compatibility.

An Operation Manager is responsible for managing a single |opsvc| and is
associated with the service via its ``OperationServiceBridge``.

When executing operations via an Operation Manager, the manager guarantees a 
completion callback within the life-cycle of the hosting Activity.

For the purposes of the following examples, we will be using the 
``SupportOperationManager`` as its more likely you will require backward 
compatibility, however usage of the ``OperationManager`` is equivalent.

The Operation Manager allows us to easily handle operation callbacks and 
life-cycle in much the same way the Android Loader API does.

Operation Codes
"""""""""""""""
we must first represent each operation we want to execute with a unique 
code (which must be 1 or greater) which we define as an integer constant, 
for instance:

.. code-block:: java

   public class MovieListFragment extends ListFragment {
   
      private static final int OP_GET_MOVIES = 1;
      
   ...
      
Creating an Operation Manager
"""""""""""""""""""""""""""""
We can then create an instance of an Operation Manager, the following example 
shows how we can manage our Movies |opsvc|:

.. code-block:: java

   private SupportOperationManager<MoviesServiceBridge> mOperationManager;

   @Override
   public void onActivityCreated(Bundle savedInstanceState) {
      super.onActivityCreated(savedInstanceState);
      
      mOperationManager = SupportOperationManager.create(getFragmentManager(), 
                  MoviesServiceBridge.getInstance(),
                  mOperationManagerCallbacks);
   }
   
In the example we construct a new ``SupportOperationManager<MoviesServiceBridge>`` in
a fragments ``onActivityCreated(Bundle)`` method, this is important since the manager needs
to be introduced early into an activity or fragments life-cycle.

.. note::
   In order to construct an Operation Manager, it requires a Fragment Manager as
   it uses a Worker Fragment to persist its state.

Running Operations
""""""""""""""""""
To run operations we use the Operation Managers ``runOperation(int, boolean)``
method:

.. code-block:: java

   mOperationManager.runOperation(OP_GET_MOVIES, false);
      
The example uses the manager to run an operation that we represented as 
``OP_GET_MOVIES``, the second argument tells the manager if we should force the 
operation to run, by providing the value of ``false`` means to only run the 
operation if it has not yet been run.

.. topic:: The Force Flag

   The Operation Manager guarantees that the operation will run and the 
   associated completion callback will be received, even if a  configuration 
   change occurs such as rotating the screen.
   
   When we call ``runOperation(int, boolean)`` and set the force flag to false, 
   tells the Operation Manager `"Only run this operation if its not been run 
   before but call me back in either case"`, effectively the result is cached and 
   invoking it multiple times will cause a callback with the cached result.
   
   We can set the force flag to true if we want to clear the cached result and
   actually force the operation to queue and run again, this behavior can be
   convenient when dealing with configuration changes or unpredictable 
   user behavior such as navigating away from your application whilst its loading 
   or even receiving interruptions from other applications, such as a phone call.

Operation Manager Callbacks
"""""""""""""""""""""""""""
When we construct an Operation Manager, we need to provide an implementation of
``OperationManagerCallbacks<T extends OperationServiceBridge>`` which is 
responsible for actually running the operation and handling the completion of
operations as follows:

.. code-block:: java

   private OperationManagerCallbacks<MoviesServiceBridge> mOperationManagerCallbacks
      = new OperationManagerCallbacks<MoviesServiceBridge>() {

      @Override
      public void onOperationComplete(MoviesServiceBridge bridge, int code, Bundle result, boolean fromCache) {
      }

      @Override
      public int createOperation(MoviesServiceBridge bridge, int code) {
      
      }
      
      @Override
      public void onOperationPending(MoviesServiceBridge bridge, int code) {
      }
   };

.. rubric:: Implementing the ``createOperation(...)`` Callback 

For each operation we want to execute we must implement at least ``onOperationComplete(...)`` 
and ``createOperation(...)``.

To implement ``createOperation(...)`` we simply use the bridge to execute the
operation for the user code ``OP_GET_MOVIES`` we used to represent it:

.. code-block:: java

   @Override
   public int createOperation(MoviesServiceBridge bridge, int code) {
      if(code == OP_GET_MOVIES) {
         return bridge.executeGetMoviesOperation();
      }
      
      return 0;
   }

In the example we use the bridge to execute the ``GetMoviesOperation`` via
``executeGetMoviesOperation()`` if the code matches ``OP_GET_MOVIES`` returning the 
result, in any other case we simply return 0 to indicate that there is no 
matching code.

.. rubric:: Implementing the ``onOperationComplete(...)`` Callback 

The ``onOperationComplete(...)`` callback provides the opportunity to examine and act
upon the completion of an operation, typically binding data or showing an error,
for example:

.. code-block:: java

   @Override
   public void onOperationComplete(MoviesServiceBridge bridge, int code, Bundle result, boolean fromCache) {
      if(code == OP_GET_MOVIES) {
         if(Operation.isResultOk(result)) {
            
            getLoaderManager().initLoader(LOADER_MOVIES, null, mLoaderCallbacks);
            
         } else {
            Throwable error = Operation.getResultError(result);
            
            Toast.makeText(getActivity(), error.getMessage(), Toast.LENGTH_LONG).show();
         }
      }
   }

In the example, the ``code`` argument is checked against the ``OP_GET_MOVIES`` 
code, if it matches, we know that the completing operation is the one that we 
executed, we can then check the result with the helper 
:java:extdoc:`Operation.isResultOk(Bundle) <com.robotoworks.mechanoid.ops.Operation.isResultOk(android.os.Bundle)>`, 
if OK, we can then perform actions based on an OK result, such as initializing a loader
as in the example, or, if the result is not OK, we can use the helper 
:java:extdoc:`Operation.getResultError(Bundle) <com.robotoworks.mechanoid.ops.Operation.getResultError(android.os.Bundle)>` to
extract the error from the Bundle, and act on the error.

.. rubric:: Implementing the ``onOperationPending(...)`` Callback 

The final callback ``onOperationPending(...)`` is called immediately after you
call ``runOperation(int, boolean)`` for the first time, or you if you set the
force flag to true.

It is also called when the Operation Manager recovers from a configuration 
change such as switching the orientation of the device.

This makes the ``onOperationPending(...)`` callback a convenient place to show 
loading indicators, as in the following example:

.. code-block:: java

   @Override
   public void onOperationPending(MoviesServiceBridge bridge, int code) {
      setListShown(false);
   }

To see a working example of the concepts described here |link| See 
`MovieListFragment.java <https://github.com/robotoworks/mechanoid/blob/master/examples/movies/src/com/robotoworks/example/movies/ui/MovieListFragment.java>`_.
 
Service Listeners
-----------------
In most cases when we are running operations from the UI, we benefit greatly
from using an ``OperationManager``, however, operation managers are bound
to the lifecycle of an ``Activity`` since they were designed to automatically
manage operation state across configuration changes, in much the same way the
Loader Manager API manages ``Loader`` state.

Under the hood, the ``OperationManager`` registers an 
:java:extdoc:`OperationServiceListener <com.robotoworks.mechanoid.ops.OperationServiceListener>`, 
with a ``ServiceBridge``.

In non-UI scenarios we can also register an ``OperationServiceListener`` with 
our bridge.

The following example shows how we can define a new listener.

.. code-block:: java

   private OperationServiceListener mOperationListener = new OperationServiceListener() {
      @Override
      public void onOperationComplete(OperationServiceBridge bridge, int requestId, Bundle result) {
         // TODO Implement completion logic
      }
   };
   
Once defined we can then implement the necessary logic to handle the completion 
of operations.

In order to implement the ``onOperationComplete(...)`` callback, we need to
identify which operation is completing, the ``requestId`` argument represents
the id we recieved when executing the operation with a bridge.

If we recall from the |ref| :ref:`executing-operations` section we saw the 
example:

.. code-block:: java

   MoviesServiceBridge bridge = MoviesServiceBridge.getInstance();
   
   int id = bridge.executeAddMovieOperation("The Godfather", "Movie about gangstas.", 1972);
   
The id returned from executing an operation, will be the id that will be given
as the ``requestId`` of the ``onOperationComplete(...)`` callback.

We can then use this id to identify our operation and act upon it, for example:

.. code-block:: java

   @Override
   public void onOperationComplete(OperationServiceBridge bridge, int requestId, Bundle result) {
      if(id == requestId) {
         if(Operation.isResultOk(result)) {
            // TODO Do something if the result is OK
         } else {
            Throwable error = Operation.getResultError(result);
            
            // TODO Do something with error
         }
      }
   }

The example shows that we can act upon completion of an operation in much the
same way as we do with ``OperationManagerCallbacks`` but we work directly with
Operation Request ID's.
