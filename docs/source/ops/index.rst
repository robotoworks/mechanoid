.. |opsvc| replace:: Operation Service
.. |opsvcdef| replace:: Operation Service Definition

|mechops|
=========
.. note:: 
   You must install the Mechanoid Plugin before you can use |mechops|.
   |ref| See :doc:`/start`
   
|mechops| is a framework for defining and performing potentially long-running 
asynchronous operations, decoupled from your UI.

You define your operations using a simple language (DSL), implement some 
generated operation stubs and then use a generated API to execute them.

The approach makes use of the Android ``Service`` Component, along with support 
classes to queue operations, execute operations and handle operation life-cycle 
callbacks.

The design pattern was first seen in 
|link| `Virgil Dobjanschi's Google IO 2010 REST Presentation <http://www.youtube.com/watch?v=xHXn3Kg2IQE>`_

In |mechops| we call this design the **Operation Service Pattern**.

In |mechops| we define an |opsvc| using a simple language (DSL), for example:-

.. code-block:: mechops

   package com.robotoworks.example.movies.ops
   
   service Movies {
      operation getMovies()
      operation addMovie(String title, String description, int year)
   }
   
In this example we define two operations, ``getMovies()`` and ``addMovie(...)``.

We can then use the generated code to execute them:

.. code-block:: java

   Intent operationIntent = AddMovieOperation.newIntent("The Godfather", "Movie about gangstas.", 1972);
   
   int id = Ops.execute(operationIntent);
   
The following sections describe the syntax of the DSL, and how we can use the
generated |opsvc| API.

.. topic:: Example Project

   The examples used in this documentation are based on an example project available
   on github:
   
   |link| https://github.com/robotoworks/mechanoid/tree/master/examples/movies

The |mechops| File
------------------
We define our |opsvc| in a file with the extension ``mechops``,
for instance ``movies.mechops``.

We can create a mechops file using the |mechops| File Wizard. In eclipse go to
``New > Other > Mechanoid > Mechanoid Ops File``, the |mechops| wizard will
launch:

.. figure:: /images/screens/wizard-mechops.png


The following should be considered when providing values for the wizard.

* **Folder** is where you want to create the file typically ``/project/models`` 
  is a good place to keep your Mechanoid Files.
* **Package** is where you want to generate the code, all code will be generated 
  to the given java package.
* **Name** is the name of your operation service, this name will be used as a 
  prefix for all the classes that make up your Operation Service API
  
On completing the wizard, a new file will be created, the contents will
contain an empty service definition:

.. code-block:: mechops

   package com.robotoworks.example.movies.ops
   
   service Movies {
      
   }
   
The Service Definition
----------------------
In |mechops| we use the ``service`` keyword followed by a unique name to define
a single Operation Service.

The following example shows how we define a service.

.. code-block:: mechops

   service Movies {
      
   }
   
In a service definition we can define many operations discussed in the following
sections.

.. topic:: The generated code

   When editing and saving mechnet files, code is generated, given a service
   with the name of ``Movies``, as in the above example, the following code is
   generated.
   
   * A user editable ``MoviesService``, and a base ``AbstractMoviesService``, the
     service mainly delegates incoming intents to an ``OperationProcessor``, you
     do not normally need to touch this but you may want to change the services
     behavior slightly such as making it a foreground service.
   * A user editable ``MoviesProcessor``, and a base ``AbstractMoviesProcessor``, 
     this is where operations are queued and executed using a ``HandlerThread``.
   * A user editable ``MoviesOperationRegistry`` and a base 
     ``AbstractMoviesOperationRegistry``, this is where intent actions and operation
     implementations are associated.
     
   In most circumstances you should not need to edit any of the generated files,
   if you do need to edit them, then you should only edit the user editable files.
   
   .. note:: 

      Code that should not be edited is generated by default to the **src-gen** folder.
      Code that can be edited with by generated by default to the **src** folder.

Registering the Service
-----------------------
|mechops| uses an Android ``Service`` component implementation for every 
|opsvcdef|, this service must be registered in the ``AndroidManifest.xml``
like any other service.

Taking the ``Movies`` service example defined in the previous section, a 
``MoviesService`` class will be generated which should be registered as follows:

.. code-block:: xml

   <service
      android:name="com.robotoworks.example.movies.ops.MoviesService"
      android:exported="false" >
   </service>

The format of the generated Android ``Service`` would be 
``{package_name}{service_name}Service``, where ``{package_name}`` is the name 
of the package element in your service definition, and likewise, 
``{service_name}`` is the name of your service, in our case, ``Movies``, which
makes the complete name ``com.robotoworks.example.movies.ops.MoviesService``.
   
Defining Operations
-------------------
Defining Operations with |mechops| is similar to defining methods in java, with
the exception that |mechops| only supports primitives and ``Parcelable`` for
operation arguments, for example:

.. code-block:: mechops

   package com.robotoworks.example.movies.ops
   
   service Movies {
      operation getMovies()
      operation addMovie(String title, String description, int year)
   }
   
The example defines two operations, an argumentless ``getMovies()`` operation, 
and a ``addMovie(...)`` operation with arguments.

.. _operation-uniqueness:

Operation Uniqueness
--------------------
By default, when executing operations with the generated Operation Service API, 
all operations are considered unique.

An operation that is unique is an operation where only one of its kind can
exist in the background queue, or one that is currently executing.

An operation is considered unique if it is of the same signature and has the same 
argument values, for instance ``addMovie(String, String, int)``.

We can use the generated API to execute operations:

.. code-block:: java

   Intent intentA = AddMovieOperation.newIntent("The Godfather", "Movie about gangstas.", 1972);
   Intent intentB = AddMovieOperation.newIntent("The Godfather", "Movie about gangstas.", 1972);
   
   int idA = service.execute(intentA);
   int idB = service.execute(intentB);

If an operation is unique, in the example above, executing the second operation
would return the same result (Operation ID), if the first operation is 
in the queue or currently executing, such that ``idA == idB``.

.. topic:: Why Make Operations Unique?

   Making operations unique can be resourceful, for example if two callers 
   execute the same operation with the same arguments it stands to reason that they 
   could be interested in the same result, |mechops| deals with this in a smart 
   way by intercepting this and returning the same Operation ID, when the operation 
   completes they both receive the a callback from the same completing operation.

We can specify that an operation should not be unique, with the ``not unique``
keyword, for instance:

.. code-block:: mechops

   package com.robotoworks.example.movies.ops
   
   service Movies {
      operation getMovies()
      operation addMovie(String title, String description, int year) not unique
   }
   
Executing the same operation in succession that is ``not unique`` will always
be added to the operation queue.

Sometimes we just want an operation to be partially unique, we can do this
by specifying a unique clause and a list of arguments that make it unique,
for instance, we can make the ``addMovie(...)`` operation unique by its title.

.. code-block:: mechops

   package com.robotoworks.example.movies.ops
   
   service Movies {
      operation getMovies()
      operation addMovie(String title, String description, int year) unique(title)
   }

Executing this operation, will only be added to the queue if an operation is
not currently in the queue with the same title, or currently executing with
the same title.

We can specify many arguments that make an operation unique in a comma separated 
list, for instance:

.. code-block:: mechops

   operation addMovie(String title, String description, int year) unique(title, year)

Implementing Operations
-----------------------
For each operation defined in the |opsvcdef|, a class stub is generated, with
the format of the class name as ``{operation_name}Operation`` where ``operation_name``
is the identifier given to the operation, ie:- ``getMovies()`` becomes ``GetMoviesOperation``.

.. warning:: 
   Currently, when renaming operations, a new stub is generated which would make 
   the old stub cause a compile error, if you have implemented a stub, and want to
   keep the code then you should copy it into the new stub
   
The following example shows the generated stub for ``GetMoviesOperation``:

.. code-block:: java

   public class GetMoviesOperation extends AbstractGetMoviesOperation {
      @Override
      protected OperationResult onExecute(Args args) {
         // TODO Auto-generated method stub
         return null;
      }
   }
   
When we implement operations, we add code to the ``onExecute(Args)`` method, and
return a ``OperationResult``.

The ``OperationResult`` we return should be constructed with the Mechanoid API method, 
:java:extdoc:`OperationResult.ok() <com.robotoworks.mechanoid.ops.OperationResult.ok()>` to
indicate that the operation was successful, or 
:java:extdoc:`OperationResult.error(Throwable) <com.robotoworks.mechanoid.ops.OperationResult.error(java.lang.Throwable)>` 
to indicate that an error occurred.

The following example shows how we could implement the ``onExecute(Args)`` of
the ``GetMoviesOperation`` stub.

.. code-block:: java

   @Override
   protected OperationResult onExecute(Args args) {
      
      MoviesApiClient client = MoviesApplication.getMoviesApiClient();
      
      try {
         Response<GetMoviesResult> response = client.getMovies();
         
         // Throws UnexpectedHttpStatusException if not 200 OK 
         response.checkResponseCodeOk();
         
         GetMoviesResult result = response.parse();
         
         saveMovies(result.getMovies());
         
         return OperationResult.ok();
         
      } catch (Exception e) {
         Log.e(TAG, Log.getStackTraceString(e));
         
         return OperationResult.error(e);
      }
   }

For the purposes of the example, we retrieve data using a REST client, the 
example demonstrates how we should construct the result. As previously outlined, 
if everything is ok, we return ``OperationResult.ok()``, in the event of 
an error we return ``OperationResult.error(Throwable)``.

Operations with arguments, such as the ``addMovie(...)`` operation we saw earlier,
make their arguments available to the operation stub through a generated ``Args`` class, 
for instance given the operation:

.. code-block:: mechops

   operation addMovie(String title, String description, int year) 

We can access the arguments in ``onExecute(Args)`` as follows:

.. code-block:: java

   @Override
   protected OperationResult onExecute(Args args) {
      
      // We can get arguments like this:
      String title = args.title;
      String description = args.description;
      int year = args.year;
      
      ...
   }
   
.. _executing-operations:

Executing Operations
--------------------
To execute operations we use an ``Intent`` to describe which operation to execute and
what the arguments should be, to construct the intent we use the generated static
helper method ``newIntent(...)`` for a given operation, for example:

.. code-block:: java

   Intent intent = AddMovieOperation.newIntent("The Godfather", "Movie about gangstas.", 1972);

We can then execute the operation intent using the ``Ops`` API.

.. code-block:: java
   
   Ops.execute(intent);

Executing an operation always returns an Operation ID. For each new invocation of ``Ops.execute(Intent)`` an 
incrementing ID is assigned that uniquely identifies a request to execute an operation, 
with the exception of operation uniqueness (see |ref| :ref:`operation-uniqueness`) 
where the same ID could be returned for a pending or currently executing operation.

.. topic:: The Operation ID
   
   Executing operations happens asynchronously, behind the scenes
   the intent to execute the operation is put into a queue managed by an ``OperationProcessor``.
   The operation processor is responsible for taking the next operation from the
   queue and executing it until no operations are left to process.
   
   With this in mind, when we invoke ``Ops.execute(Intent)``, we
   get an **ID** back, which we can use to uniquely identify an operation.
   
   In order to know what is happening with an operation, we rely on call-backs 
   discussed later.
 
As well as executing operations we can also use ``Ops`` to check if an 
operation is pending completion (either in the queue or executing), for this
we need the Operation ID that was returned to us when we executed
the operation:

.. code-block:: java

   boolean pending = Ops.isOperationPending(id);
   
  
Operation Executors
-------------------
The most convenient way to execute operations from a UI class such as 
an ``Activity`` or a ``Fragment`` is with an ``OperationExecutor``.

An executor can manage the life-cycle of a single operation at a time.

When executing an operation, the executor guarantees a 
completion callback within the life-cycle of the hosting Activity.

An executor allows us to easily handle operation callbacks and 
life-cycle in much the same way the Android Loader API does.

Operation Executor Keys
"""""""""""""""""""""""
Each executor must be instantiated with a unique key which is used to persist
the executor through state, we can define this key as a constant.

.. code-block:: java

   public class MovieListFragment extends ListFragment {
   
      private static final String OP_GET_MOVIES = "OP_GET_MOVIES";
      
   ...
      
Creating an executor
""""""""""""""""""""
The following example shows how we create an executor.

.. code-block:: java

   @Override
   public void onActivityCreated(Bundle savedInstanceState) {
      super.onActivityCreated(savedInstanceState);
      
      mGetMoviesOperationExecutor = new OperationExecutor(
          OP_GET_MOVIES, savedInstanceState, mOperationExecutorCallbacks);
      
   }
   
In the example we construct a new ``OperationExecutor`` in
a fragments ``onActivityCreated(Bundle)`` method, this is important since the executor needs
to be introduced early into an activity or fragments life-cycle and is really the only
place you can get hold of a state ``Bundle``, as mentioned we provide a key ``OP_GET_MOVIES`` 
so the executor can uniquely persist the state of the executor. The last argument
we provide callbacks which we will look at later.

Saving State
""""""""""""
The most important requirement of an operation executor is to save its state
which we can do in ``onSaveInstanceState(Bundle)`` as follows.

.. code-block:: java

   @Override
   public void onSaveInstanceState(Bundle outState) {
      super.onSaveInstanceState(outState);
      
      mGetMoviesOperationExecutor.saveState(outState);
   }
   
This enables the executor to track an operation through configuration changes
using the key give during instantiation.

Executing Operations
""""""""""""""""""""
To execute operations using the manager we use the executors ``execute(Intent, boolean)``
method:

.. code-block:: java

   mGetMoviesOperationExecutor.execute(GetMoviesOperation.newIntent(), OperationExecutor.MODE_ONCE);
      
The example uses the executor to execute an operation described by the given intent, 
the last argument tells the executor how we want the 
operation to execute, by providing the value of ``OperationExecutor.MODE_ONCE`` means to only run the 
operation if it has not yet been run.

Execution Modes
"""""""""""""""
Currently the operation executor supports 3 operating modes that are useful
in certain scenarios, the default mode is ``MODE_ONCE``.

The following points outline the purpose of each mode.

* ``MODE_ONCE``
   The ``OperationExecutor`` guarantees that the operation will run and the 
   associated completion callback will be called once, even if a configuration 
   change occurs such as rotating the screen.
   
   When we call ``execute(Intent, boolean)`` and set the mode to ``MODE_ONCE``, 
   tells the executor `"Only run this operation if it has not been run 
   before"`.
   
* ``MODE_ALWAYS``
   We can use ``MODE_ALWAYS`` if we want to clear the cached result and
   force the operation to queue and execute again, which is useful in scenarios
   such as retrying after an operation error.
   
* ``MODE_ON_ERROR``
   This mode can be useful in scenarios where the user is resuming your application 
   where the previous operation completed with error and you do not want to bother 
   them with a retry option and just go ahead and execute the operation as if 
   nothing happened.
   
   
Dealing with Configuration Change
"""""""""""""""""""""""""""""""""
When the user rotates the device, an activity or fragment could be recreated
due to a configuration change. If this happens you may need to know what is happening
with your operation. Directly after you instantiate an executor you can check
if it is complete.

.. code-block:: java

   mGetMoviesOperationExecutor = new OperationExecutor(
       OP_GET_MOVIES, savedInstanceState, mOperationExecutorCallbacks);
          
   if(mGetMoviesOperationExecutor.isOk()) {
      getLoaderManager().initLoader(LOADER_MOVIES, null, mLoaderCallbacks);
   } else {
      mGetMoviesOperationExecutor.execute(GetMoviesOperation.newIntent(), OperationExecutor.MODE_ONCE);
   }
   
In the above example we check if the operation is complete and the result is ok
with the convenient ``isOk()`` method, if true we initialize a loader, otherwise 
we execute the operation.

We can also get the result from the executor if we need it with ``getResult()`` 
which can be useful if we need to know certain things about the completed operation.

.. note:: 
   An important thing to note is even though you can check ``isOk()`` you
   are always guaranteed to receive the completion callback, checking completion
   after instantiation is only really useful if you want to do something like
   reinitialize loaders or set up UI state according to the completion of an 
   operation

Executor Callbacks
""""""""""""""""""
When we construct an executor, we need to provide an implementation of
``OperationExecutorCallbacks`` which we can use to receive a callback for the
completion of operations, and a callback to tell us that the operation is pending.


.. code-block:: java

   private OperationExecutorCallbacks mOperationExecutorCallbacks 
      = new OperationExecutorCallbacks() {
   
      @Override
      public boolean onOperationComplete(String key, OperationResult result) {
         
      }
   
      @Override
      public void onOperationPending(String key) {

      }
   };
   

.. rubric:: Implementing the ``onOperationComplete(String, OperationResult)`` Callback 

The ``onOperationComplete(String, OperationResult)`` callback provides the opportunity to 
act upon the completion of an operation, typically binding data or showing an error,
for example:

.. code-block:: java

   @Override
   public boolean onOperationComplete(String key, OperationResult result) {
      if(!isAdded()) {
         return false;
      }
         
      if(OP_GET_MOVIES.equals(key)) {
         if(result.isOk()) {
            
            getLoaderManager().initLoader(LOADER_MOVIES, null, mLoaderCallbacks);
            
         } else {
            Throwable error = result.getError();
            
            Toast.makeText(getActivity(), error.getMessage(), Toast.LENGTH_LONG).show();
         }
         
         return true;
      }
      
      return false;
   }

The example shows the callback in the context of a Fragment, we should return
``true`` from the callback if we want to handle it now, or ``false`` if we want to
handle it later. At times it is desirable to not handle the callback for instance
if the fragment is being destroyed, checking the ``isAdded()`` method is one way
to check if the fragment is in a state that could handle the callback, by
returning ``false`` we will receive the callback again as a result of the of the executor 
being recovered from state, or when the execute method is invoked again.

Next in the example, the ``key`` argument is checked against the ``OP_GET_MOVIES`` 
constant, if it matches, we know that the completing operation is the one that we 
executed, we can then check the result with
:java:extdoc:`result.isOk() <com.robotoworks.mechanoid.ops.OperationResult.isOk()>`, 
if OK, we can then perform actions based on an OK result, such as initializing a loader
as in the example, or, if the result is not OK, we can get the error using
:java:extdoc:`result.getError() <com.robotoworks.mechanoid.ops.OperationResult.getError()>` to
extract the error from the Bundle, and act on the error.

.. rubric:: Implementing the ``onOperationPending(...)`` Callback 

The callback ``onOperationPending(...)`` is called immediately after you
call ``execute(Intent, int)``.

It is also called when the executor recovers from a configuration 
change such as switching the orientation of the device.

This makes the ``onOperationPending(...)`` callback a convenient place to show 
loading indicators, as in the following example:

.. code-block:: java

   @Override
   public void onOperationPending(String key) {
      if(OP_GET_MOVIES.equals(key)) {
         setListShown(false);
      }
   }

To see a working example of the concepts described here |link| See 
`MovieListFragment.java <https://github.com/robotoworks/mechanoid/blob/master/examples/movies/src/com/robotoworks/example/movies/ui/MovieListFragment.java>`_.
 
Service Listeners
-----------------
In most cases when we are running operations from the UI, we benefit greatly
from using an ``OperationExecutor``, however in more advanced scenarios we
should use Service Listeners if we need to do something special when
handling operation lifecycles.

Under the hood, an ``OperationExecutor`` registers an 
:java:extdoc:`OperationServiceListener <com.robotoworks.mechanoid.ops.OperationServiceListener>`, 
with ``Ops``.

In non-UI scenarios we can also register an ``OperationServiceListener`` with ``Ops``.

The following example shows how we can define a new listener.

.. code-block:: java

   private OperationServiceListener mOperationListener = new OperationServiceListener() {
      @Override
      public void onOperationComplete(int requestId, OperationResult result) {
         // TODO Implement completion logic
      }
   };
   
Once defined we can then implement the necessary logic to handle the completion 
of operations.

In order to implement the ``onOperationComplete(...)`` callback, we need to
identify which operation is completing, the ``id`` argument represents
the id we recieved when executing the operation.

If we recall from the |ref| :ref:`executing-operations` section we saw the 
example:

.. code-block:: java

   Intent intent = AddMovieOperation.newIntent("The Godfather", "Movie about gangstas.", 1972);

   int addMovieOperationId = Ops.execute(intent);
   
The id returned from executing an operation, will be the id that will be given
as the ``id`` of the ``onOperationComplete(...)`` callback.

We can then use this id to identify our operation and act upon it, for example:

.. code-block:: java

   @Override
   public void onOperationComplete(int id, OperationResult result) {
      if(id == addMovieOperationId) {
         if(result.isOk()) {
            // TODO Do something if the result is OK
         } else {
            Throwable error = result.getError();
            
            // TODO Do something with error
         }
      }
   }

The example shows that we can act upon completion of an operation in much the
same way as we do with ``OperationManagerCallbacks`` but we work directly with
Operation ID's.

Proguard
--------
The following lines should be added to your proguard-project.txt

.. code-block:: java

   -keepclassmembers class * extends com.robotoworks.mechanoid.ops.OperationService {
       public static <fields>;
   }
